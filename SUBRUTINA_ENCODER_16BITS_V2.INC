;***************************************************************************
; SUBRUTINA DE LECTURA DE ENCODER INCREMENTAL ROTATIVO DE 2 PINES (CLK y DT)
; VERSION 2.0
; 
; REALIZADA POR ING. C.N. JOSUE NORBERTO MARTINEZ F. (SEPT. 2021)
;				produccionesrek@gmail.com
;				http://prdiagramasyelectronica.blogspot.com/
;
;***************************************************************************
; V2
; *Se elimina un registro auxiliar.
; *Pin CLK y DT configurables.
; *Funcionamiento para diferentes frecuencias de operacion.
; *Cantidad de ciclos en Bucle configurable.
;***************************************************************************
;
; EL CODIGO DE ESTA SUBRUTINA PUEDE SER AGREGADO AL CODIGO DEL PROGRAMA 
; PRINCIPAL O PUEDE SER INCLUIDO UTILIZANDO EL COMANDO ".INCLUDE"
;
;		EJEMPLO:
;		.INCLUDE "SUBRUTINA_ENCODER_16BITS_V2.INC"
;
;
; PARA EJECUTAR ESTA SUBRUTINA SE DEBEN SEGUIR LOS SIGUIENTES PASOS:
;
;	1.-	DEFINIR CONSTANTES Y REGISTROS DE LA SUBRUTINA
;	2.-	INICIALIZAR LA SUBRUTINA					
;	3.-	UTILIZAR EL COMANDO "RCALL" PARA EJECUTAR LA SUB-RUTINA
;	4.- LEER EL VALOR ACTUALIZADO DEL CONTADOR
;
; ** NOTAS **:
;
;	PARA EL CORRECTO FUNCIONAMIENTO DE ESTA SUBRUTINA, SE RECOMIENDA EJECUTARLA DENTRO DE UN BUCLE, PARA
;	MANTENER ACTUALIZADO EL VALOR DEL CONTADOR EN TODO MOMENTO
;	
;
;	*NO ES NECESARIO CONFIGURAR EL PUERTO DDRX DEL ENCODER, 
;	 YA QUE SE REALIZA DE FORMA AUTOMÁTICA DENTRO DE LA SUBRUTINA.
;
;	*NO UTILIZAR R16 NI R17 PARA DEFINIR LOS REGISTROS: 
;	 "ENCODER_CONTADOR_LOW", NI "ENCODER_CONTADOR_HIGH"
;
;	*LA CONSTANTE "ENCODER_MAX_CONT" Debe ser menor a $FFFF
;
;	*LA CONSTANTE "ENCODER_CONT_INICIAL" DEBE SER MAYOR A ENCODER_MIN_CONT", PERO
;	 MENOR A "ENCODER_MAX_CONT"
;
;	*ESTA SUBRUTINA UTILIZA LOS REGISTROS R16 Y R17 DURANTE SU OPERACION
;
;---------------------------------------------------------------------
;--------------------- EJEMPLO DE IMPLEMENTACION:---------------------
;---------------------------------------------------------------------
/*

;DEFINICION DE CONSTANTES:
	.EQU ENCODER_PORTX			=	PORTB	;PUERTO EN EL QUE SE CONECTA EL ENCODER
	.EQU ENCODER_CLK			=	PB0		;PIN DE SEÑAL CLK DEL ENCODER
	.EQU ENCODER_DT				=	PB1		;PIN DE SEÑAL DT DEL ENCODER
	.EQU ENCODER_MAX_CONT		=	$000F	;VALOR MAXIMO PERMITIDO DEL CONTADOR, $FFFF = 65,535
	.EQU ENCODER_MIN_CONT		=	$0000	;VALOR MINIMO PERMITIDO DEL CONTADOR, $0000 = 0
	.EQU ENCODER_CONT_INICIAL	=	$0003	;VALOR INICIAL DEL CONTADOR
	.EQU ENCODER_LOOP			=	10		;CANTIDAD DE VECES QUE SERÁ SENSADO EL ENCODER CADA VEZ
											;QUE SE EJECUTA LA SUBRUTINA (MAX. 255)
	.EQU ENCODER_FREC_AVR		=	4		;FRECUENCIA DEL MICROCONTROLADOR EN MHZ (ENTEROS)

;DEFINICION DE REGISTROS ( *** NO UTILIZAR R16 ni R17 *** )
	.DEF ENCODER_CONTADOR_LOW	=	R19		; CONTADOR BYTE LOW
	.DEF ENCODER_CONTADOR_HIGH	=	R20		; CONTADOR BYTE HIGH


;INICIALIZA LA SUBRUTINA DE ENCODER	
		RCALL INICIALIZA_ENCODER				


MAIN:

	RCALL SENSAR_ENCODER					;EJECUTA SUBRUTINA DE LECTURA
	MOV R25, ENCODER_CONTADOR_LOW			;OBTIENE EL VALOR DEL CONTADOR PARA REALIZAR OTRA FUNCION
	MOV R26, ENCODER_CONTADOR_HIGH

RJMP MAIN

.INCLUDE "SUBRUTINA_ENCODER_16BITS_V2.INC"

*/
;---------------------------------------------------------------------
;------------------------- TERMINA EJEMPLO:---------------------------
;---------------------------------------------------------------------

;***************************************************************************
;CODIGO

;V2
;DIRECCION DE MEMORIA PARA GUARDAR CONTADORES TEMPORALES
;SRAM_START + DIR_CONTADORES
;SRAM_START + DIR_ENCODER_POS
	
	.EQU DIR_CONTADORES		= $10
	.EQU DIR_ENCODER_POS	= $11

;ADVERTENCIAS PARA EL COMPILADOR

	.IF ENCODER_MAX_CONT > $FFFF
	.ERROR " *ENCODER_MAX_CONT* Debe ser igual o menor a $FFFF"
	.ENDIF

	.IF ENCODER_LOOP > $FF
	.ERROR " *ENCODER_LOOP* Debe ser igual o menor a $FF"
	.ENDIF

	.IF ENCODER_CONT_INICIAL > ENCODER_MAX_CONT
	.WARNING " *ENCODER_CONT_INICIAL* esta fuera de rango"
	.ENDIF

	.IF ENCODER_CONT_INICIAL < ENCODER_MIN_CONT
	.WARNING " *ENCODER_CONT_INICIAL* esta fuera de rango"
	.ENDIF

INICIALIZA_ENCODER:
	
	;V2
	;RESPALDA REGISTRO
		PUSH R17
	;V2
	;REESTABLECE CONTADOR EN MEMORIA SRAM
		CLR R16
		STS (SRAM_START + DIR_CONTADORES),R16

	;CONFIGURA DDRX *********************************

		CBI ENCODER_PORTX - 1, ENCODER_CLK
		CBI ENCODER_PORTX - 1, ENCODER_DT

	;CARGA POSICION INICIAL DEL ENCODER ***********
		
		IN R16, ENCODER_PORTX - 2
		LDI R17, (1<<ENCODER_DT|1<<ENCODER_CLK)
		AND R16, R17
		STS (SRAM_START + DIR_ENCODER_POS), R16

	;ESTABLECE VALOR INICIAL DEL CONTADOR

		LDI ENCODER_CONTADOR_LOW, LOW(ENCODER_CONT_INICIAL)
		LDI ENCODER_CONTADOR_HIGH, HIGH(ENCODER_CONT_INICIAL)

	;V2
	;RECUPERA REGISTRO
		POP R17

RET


SENSAR_ENCODER:
	
	;ESTADO ANTERIOR = 00?
		LDS R16, (SRAM_START + DIR_ENCODER_POS)
		CPI R16, 0b0000_0000
		BREQ LOOP_00
		RJMP ANTERIOR_10

	LOOP_00:
		
		;RESTABLECE CONTADOR Y RESPALDA
			LDI R16, ENCODER_LOOP
			PUSH R16

		LOOP_00_SUB:

			;LEE ESTADO ACTUAL
				RCALL LEE_ESTADO_ACTUAL

			;ACTUAL = 10?
				CBR R17, (1<<ENCODER_CLK)
				CP R16, R17
				BREQ PARCHE_DISMINUYE_CONTADOR
		
			;ACTUAL = 01?
				SBR R17, (1<<ENCODER_CLK)
				CBR R17, (1<<ENCODER_DT)
				CP R16, R17
				BREQ PARCHE_INCREMENTA_CONTADOR
		
			;COMPARA CONTADOR
				POP R16
				DEC R16
				PUSH R16
				CPI R16, 0
				BRNE LOOP_00_SUB
				POP R16

RET


	;ESTADO ANTERIOR = 10?
		ANTERIOR_10:

		LDS R16, (SRAM_START + DIR_ENCODER_POS)
		LDI R17, (1<<ENCODER_DT)
		CP R16, R17
		BREQ LOOP_10
		RJMP ANTERIOR_11

	LOOP_10:

		;RESTABLECE CONTADOR Y RESPALDA
			LDI R16, ENCODER_LOOP
			PUSH R16

		LOOP_10_SUB:

			;LEE ESTADO ACTUAL
				RCALL LEE_ESTADO_ACTUAL

			;ACTUAL = 11?
				CP R16, R17
				BREQ PARCHE_DISMINUYE_CONTADOR
		
			;ACTUAL = 00?
				CPI R16, 0b0000_0000
				BREQ PARCHE_INCREMENTA_CONTADOR
		
			;COMPARA CONTADOR
				POP R16
				DEC R16
				PUSH R16
				CPI R16, 0
				BRNE LOOP_10_SUB
				POP R16

RET
	
	;PARCHES
		PARCHE_DISMINUYE_CONTADOR:
		RJMP DISMINUYE_CONTADOR

		PARCHE_INCREMENTA_CONTADOR:
		RJMP INCREMENTA_CONTADOR


	;ESTADO ANTERIOR = 11?
		ANTERIOR_11:
		LDS R16, (SRAM_START + DIR_ENCODER_POS)
		LDI R17, (1<<ENCODER_DT|1<<ENCODER_CLK)
		CP R16, R17
		BREQ LOOP_11
		RJMP ANTERIOR_01

	LOOP_11:
		
		;RESTABLECE CONTADOR Y RESPALDA
			LDI R16, ENCODER_LOOP
			PUSH R16

		LOOP_11_SUB:

		;LEE ESTADO ACTUAL
			RCALL LEE_ESTADO_ACTUAL

		;ACTUAL = 01?
			CBR R17, (1<<ENCODER_DT)
			CP R16, R17
			BREQ PARCHE_DISMINUYE_CONTADOR
		
		;ACTUAL = 10?
			SBR R17, (1<<ENCODER_DT)
			CBR R17, (1<<ENCODER_CLK)
			CP R16, R17
			BREQ PARCHE_INCREMENTA_CONTADOR
		
		;COMPARA CONTADOR
			POP R16
			DEC R16
			PUSH R16
			CPI R16, 0
			BRNE LOOP_11_SUB
			POP R16

RET


	;ESTADO ANTERIOR = 01?
		ANTERIOR_01:
		LDS R16, (SRAM_START + DIR_ENCODER_POS)
		LDI R17, (1<<ENCODER_CLK)
		CP R16, R17
		BREQ LOOP_01
		RJMP SENSAR_ENCODER

	LOOP_01:

		;RESTABLECE CONTADOR Y RESPALDA
			LDI R16, ENCODER_LOOP
			PUSH R16

		LOOP_01_SUB:

			;LEE ESTADO ACTUAL
				RCALL LEE_ESTADO_ACTUAL

			;ACTUAL = 00?
				CPI R16, 0b0000_0000
				BREQ PARCHE_DISMINUYE_CONTADOR
		
			;ACTUAL = 11?
				CP R16, R17
				BREQ PARCHE_INCREMENTA_CONTADOR
		
			;COMPARA CONTADOR
				POP R16
				DEC R16
				PUSH R16
				CPI R16, 0
				BRNE LOOP_01_SUB
				POP R16

RET


	INCREMENTA_CONTADOR:
		;ACTUALIZA POSICION ANTERIOR
			STS (SRAM_START + DIR_ENCODER_POS), R16

		POP R16

		;COMPRUEBA VALOR DEL CONTADOR 
			CPI ENCODER_CONTADOR_LOW, LOW(ENCODER_MAX_CONT)
			BRNE INC_CONT_CONTINUA1
			CPI ENCODER_CONTADOR_HIGH, HIGH(ENCODER_MAX_CONT)
			BREQ INC_CONT_CONTINUA2

		INC_CONT_CONTINUA1:
			;SUMA 1

				;V2
				;CUENTA 4 ESTADOS EN ENCODER PARA 1 INCREMENTO EN CONTADOR
					LDS R16, (SRAM_START + DIR_CONTADORES)
				;SI CONTADOR ES NEGATIVO, REESTABLECE
					CPI R16,0
					BRLT ICC1_REESTABLECE
					RJMP ICC1_CONTINUA
					ICC1_REESTABLECE:
						CLR R16
					ICC1_CONTINUA:
						INC R16
						STS (SRAM_START + DIR_CONTADORES), R16
						CPI R16, 4
						BRNE INC_CONT_CONTINUA2
						CLR R16
						STS (SRAM_START + DIR_CONTADORES), R16
				;
				LDI R16, 1
				PUSH R17
				CLR R17
				ADD ENCODER_CONTADOR_LOW, R16
				ADC ENCODER_CONTADOR_HIGH, R17
				POP R17

		INC_CONT_CONTINUA2:
			RCALL ENC_DELAY
RET


	DISMINUYE_CONTADOR:
		;ACTUALIZA POSICION ANTERIOR
			STS (SRAM_START + DIR_ENCODER_POS), R16

		POP R16

		;COMPRUEBA VALOR DEL CONTADOR 
			CPI ENCODER_CONTADOR_LOW, LOW(ENCODER_MIN_CONT)
			BRNE DISM_CONT_CONTINUA1
			CPI ENCODER_CONTADOR_HIGH, HIGH(ENCODER_MIN_CONT)
			BREQ DISM_CONT_CONTINUA2

		DISM_CONT_CONTINUA1:
			
			;V2
			;CUENTA 4 ESTADOS EN ENCODER PARA 1 DECREMENTO EN CONTADOR
				LDS R16, (SRAM_START + DIR_CONTADORES)
			;SI CONTADOR ES POSITIVO, REESTABLECE
				CPI R16,1
				BRGE DCC1_REESTABLECE
				RJMP DCC1_CONTINUA
				DCC1_REESTABLECE:
					CLR R16
				DCC1_CONTINUA:
					DEC R16
					STS (SRAM_START + DIR_CONTADORES), R16
					CPI R16, -4
					BRNE DISM_CONT_CONTINUA2
					CLR R16
					STS (SRAM_START + DIR_CONTADORES), R16
			;
			;RESTA 1
				CLR R16
				SUBI ENCODER_CONTADOR_LOW, 1
				SBC ENCODER_CONTADOR_HIGH, R16
			
		DISM_CONT_CONTINUA2:
			RCALL ENC_DELAY
		
RET

;***************************************************************************
;SUBRUTINA AUXILIAR DE RETARDO
; 0.5 milisegundos aprox

ENC_DELAY:
		
		PUSH R16
		LDI R16, ENCODER_FREC_AVR
		
		EDMS_LOOP1:

				PUSH R16
				LDI R16, 123
			
				EDMS_LOOP2:
						DEC R16
						CPI R16, 0
						BRNE EDMS_LOOP2

				POP R16
				DEC R16
				CPI R16, 0
				BRNE EDMS_LOOP1

		POP R16

RET

;***************************************************************************
LEE_ESTADO_ACTUAL:

	IN R16, ENCODER_PORTX - 2
	LDI R17, (1<<ENCODER_DT|1<<ENCODER_CLK)
	AND R16, R17

RET


